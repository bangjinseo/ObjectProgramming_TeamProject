#include <SFML/Graphics.hpp>
#include <iostream>
#include <vector>
#include <string>

std::wstring formatMoney(int money) {
    std::wstring result;
    std::wstring num = std::to_wstring(money);
    int count = 0;
    for (int i = num.size() - 1; i >= 0; --i) {
        result.insert(result.begin(), num[i]);
        count++;
        if (count % 3 == 0 && i != 0) {
            result.insert(result.begin(), L',');
        }
    }
    result += L"원";
    return result;
}

class MoneyDisplay {
private:
    int money = 0;
    sf::Text text;
    sf::Font font;

public:
    bool init() {
        if (!font.loadFromFile("NotoSansKR-SemiBold.ttf")) {
            std::cerr << "폰트 로딩 실패!" << std::endl;
            return false;
        }
        text.setFont(font);
        text.setCharacterSize(20);
        text.setFillColor(sf::Color::Yellow);
        text.setPosition(50.f, 30.f);
        text.setString(sf::String(formatMoney(money)));
        return true;
    }

    void increase() {
        money++;
        text.setString(sf::String(formatMoney(money)));
    }

    void draw(sf::RenderWindow& window) {
        window.draw(text);
    }
};

class Background {
private:
    sf::Texture texture;
    sf::Sprite sprite;
    std::string currentFile = "bg_playground.png";

public:
    bool init(const sf::RenderWindow& window) {
        return load("bg_playground.png", window);
    }

    bool load(const std::string& filename, const sf::RenderWindow& window) {
        // 텍스처 로드 전에 스무딩 비활성화 (픽셀 아트에 적합)
        texture.setSmooth(false);

        if (!texture.loadFromFile(filename)) {
            std::cerr << filename << " 로딩 실패!" << std::endl;
            return false;
        }

        sprite.setTexture(texture);

        // 이미지 크기와 창 크기 출력 (디버깅용)
        std::cout << "이미지 크기: " << texture.getSize().x << "x" << texture.getSize().y << std::endl;
        std::cout << "창 크기: " << window.getSize().x << "x" << window.getSize().y << std::endl;

        // 비율 유지하면서 스케일링하는 방식으로 변경
        float scaleX = window.getSize().x / static_cast<float>(texture.getSize().x);
        float scaleY = window.getSize().y / static_cast<float>(texture.getSize().y);

        // 이미지가 화면에 꽉 차도록 하되 비율은 유지
        float scale = std::min(scaleX, scaleY);
        sprite.setScale(scale, scale);

        // 이미지를 화면 중앙에 배치
        float offsetX = (window.getSize().x - texture.getSize().x * scale) / 2.0f;
        float offsetY = (window.getSize().y - texture.getSize().y * scale) / 2.0f;
        sprite.setPosition(offsetX, offsetY);

        currentFile = filename;
        return true;
    }

    void draw(sf::RenderWindow& window) {
        window.draw(sprite);
    }

    // 현재 배경 파일명 반환
    std::string getCurrentFile() const {
        return currentFile;
    }
};

class Character {
private:
    std::vector<sf::Texture> textures;
    sf::Sprite sprite;
    int currentFrame = 0;
    sf::Clock clock;
    float switchTime = 0.5f;

public:
    bool init() {
        textures.resize(2);
        if (!textures[0].loadFromFile("kn_beggar1.png")) {
            std::cerr << "kn_beggar1.png 로딩 실패!" << std::endl;
            return false;
        }
        if (!textures[1].loadFromFile("kn_beggar2.png")) {
            std::cerr << "kn_beggar2.png 로딩 실패!" << std::endl;
            return false;
        }

        sprite.setTexture(textures[0]);
        sprite.setScale(0.6f, 0.6f);
        sprite.setPosition(20.f, 300.f);
        return true;
    }

    void update() {
        if (clock.getElapsedTime().asSeconds() >= switchTime) {
            currentFrame = (currentFrame + 1) % 2;
            sprite.setTexture(textures[currentFrame]);
            clock.restart();
        }
    }

    void draw(sf::RenderWindow& window) {
        window.draw(sprite);
    }
};

class Game {
private:
    sf::RenderWindow window;
    MoneyDisplay moneyDisplay;
    Background background;
    Character character;

    sf::RectangleShape clickableArea;
    bool backgroundChanged = false;

public:
    Game() : window(sf::VideoMode(405, 720), "Homeless Character Animation") {}

    bool init() {
        if (!moneyDisplay.init() || !background.init(window) || !character.init())
            return false;

        clickableArea.setSize({ 182.f, 42.f });
        clickableArea.setPosition(204.f, 618.f);
        clickableArea.setOutlineColor(sf::Color::White);
        clickableArea.setOutlineThickness(2.f);

        return true;
    }

    void run() {
        while (window.isOpen()) {
            handleEvents();
            update();
            render();
        }
    }

private:
    void handleEvents() {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Space) {
                moneyDisplay.increase();
            }

            if (event.type == sf::Event::MouseButtonPressed && event.mouseButton.button == sf::Mouse::Left) {
                sf::Vector2f mousePos = window.mapPixelToCoords({ event.mouseButton.x, event.mouseButton.y });
                std::wcout << L"[클릭 위치] x: " << mousePos.x << ", y: " << mousePos.y << std::endl;

                if (!backgroundChanged && clickableArea.getGlobalBounds().contains(mousePos)) {
                    if (background.load("MovingBeggingPlace_bg.png", window)) {
                        backgroundChanged = true;
                        std::cout << "[배경 전환] MovingBeggingPlace_bg.png 적용됨\n";
                    }
                } else if (backgroundChanged && clickableArea.getGlobalBounds().contains(mousePos)) {
                    // 다시 원래 배경으로 돌아갈 수 있도록 토글 기능 추가
                    if (background.load("bg_playground.png", window)) {
                        backgroundChanged = false;
                        std::cout << "[배경 전환] bg_playground.png 적용됨\n";
                    }
                }
            }
        }
    }

    void update() {
        if (!backgroundChanged)
            character.update();
    }

    void render() {
        window.clear();
        background.draw(window);
        if (!backgroundChanged)
            character.draw(window);
        moneyDisplay.draw(window);

        // 디버깅용: 클릭 영역 표시 (필요시 주석 해제)
        // window.draw(clickableArea);

        window.display();
    }
};

int main() {
    // 디버깅 정보 출력
    std::cout << "프로그램 시작...\n";
    std::cout << "작업 디렉토리에서 이미지 파일을 찾습니다.\n";

    Game game;
    if (!game.init()) {
        std::cerr << "게임 초기화 실패!\n";
        return -1;
    }

    std::cout << "게임 초기화 성공! 실행 중...\n";
    game.run();
    return 0;
}