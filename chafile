#include <SFML/Graphics.hpp>
#include <iostream>
#include <vector>
#include <string>
#include <locale>
#include <map>

std::wstring formatMoney(int money) {
    std::wstring result;
    std::wstring num = std::to_wstring(money);
    int count = 0;
    for (int i = num.size() - 1; i >= 0; --i) {
        result.insert(result.begin(), num[i]);
        count++;
        if (count % 3 == 0 && i != 0) {
            result.insert(result.begin(), L',');
        }
    }
    result += L" 골드";
    return result;
}

class MoneyDisplay {
private:
    int money = 50000000; // 첫 번째 코드의 시작 금액 사용
    sf::Text text;
    sf::Font font;

public:
    bool init() {
        if (!font.loadFromFile("NotoSansKR-SemiBold.ttf")) {
            std::cerr << "폰트 로딩 실패!" << std::endl;
            return false;
        }
        text.setFont(font);
        text.setCharacterSize(20);
        text.setFillColor(sf::Color::Yellow);
        text.setPosition(55.f, 26.f);
        text.setString(sf::String(formatMoney(money)));
        return true;
    }

    void increase(int amount = 1) {
        money += amount;
        text.setString(sf::String(formatMoney(money)));
    }

    void addMoney(int amount) {
        money += amount;
        text.setString(sf::String(formatMoney(money)));
    }

    bool spendMoney(int amount) {
        if (money >= amount) {
            money -= amount;
            text.setString(sf::String(formatMoney(money)));
            return true;
        }
        return false;
    }

    int getMoney() const {
        return money;
    }

    void draw(sf::RenderWindow& window) {
        window.draw(text);
    }
};

class Background {
private:
    sf::Texture texture;
    sf::Sprite sprite;
    std::string currentFile = "bg_playground.png";

public:
    bool init(const sf::RenderWindow& window) {
        return load("bg_playground.png", window);
    }

    bool load(const std::string& filename, const sf::RenderWindow& window) {
        if (!texture.loadFromFile(filename)) {
            std::cerr << filename << " 로딩 실패!" << std::endl;
            return false;
        }

        sprite.setTexture(texture);
        float scaleX = window.getSize().x / static_cast<float>(texture.getSize().x);
        float scaleY = window.getSize().y / static_cast<float>(texture.getSize().y);
        sprite.setScale(scaleX, scaleY);
        currentFile = filename;
        return true;
    }

    const std::string& getCurrentFile() const {
        return currentFile;
    }

    void draw(sf::RenderWindow& window) {
        window.draw(sprite);
    }
};

class Character {
private:
    std::vector<sf::Texture> textures;
    sf::Sprite sprite;
    int currentFrame = 0;
    sf::Clock clock;
    float switchTime = 0.5f;

public:
    bool init() {
        textures.resize(2);
        if (!textures[0].loadFromFile("kn_beggar1.png")) {
            std::cerr << "kn_beggar1.png 로딩 실패!" << std::endl;
            return false;
        }
        if (!textures[1].loadFromFile("kn_beggar2.png")) {
            std::cerr << "kn_beggar2.png 로딩 실패!" << std::endl;
            return false;
        }

        sprite.setTexture(textures[0]);
        sprite.setScale(0.6f, 0.6f);
        sprite.setPosition(20.f, 300.f);
        return true;
    }

    void update() {
        if (clock.getElapsedTime().asSeconds() >= switchTime) {
            currentFrame = (currentFrame + 1) % 2;
            sprite.setTexture(textures[currentFrame]);
            clock.restart();
        }
    }

    void draw(sf::RenderWindow& window) {
        window.draw(sprite);
    }
};

class RealEstate {
public:
    struct Property {
        std::string name;
        int price;
        int maxInterest;
        bool owned;
        sf::FloatRect buttonArea;
        sf::Text buttonText;
    };

private:
    sf::Font font;
    std::map<std::string, Property> properties;
    sf::Texture buildingTexture;
    sf::Sprite buildingSprite;
    int totalSalesProfit = 0; // 역대 부동산 판매 수익 누적

public:
    int getTotalSalesProfit() const {
        return totalSalesProfit;
    }

    bool init(sf::RenderWindow& window) {
        if (!font.loadFromFile("NotoSansKR-SemiBold.ttf")) {
            std::cerr << "폰트 로딩 실패!" << std::endl;
            return false;
        }

        if (!buildingTexture.loadFromFile("building_bg.png")) {
            std::cerr << "building_bg.png 로딩 실패!" << std::endl;
            return false;
        }

        buildingSprite.setTexture(buildingTexture);
        float scaleX = window.getSize().x / static_cast<float>(buildingTexture.getSize().x);
        float scaleY = window.getSize().y / static_cast<float>(buildingTexture.getSize().y);
        buildingSprite.setScale(scaleX, scaleY);

        // 부동산 정보 초기화
        Property eng8;
        eng8.name = "8공학관";
        eng8.price = 3000;
        eng8.maxInterest = 2000;
        eng8.owned = false;
        eng8.buttonArea = sf::FloatRect(38, 352, 135, 41);
        eng8.buttonText.setFont(font);
        eng8.buttonText.setString(formatMoney(eng8.price));
        eng8.buttonText.setCharacterSize(14);
        eng8.buttonText.setFillColor(sf::Color::Black);
        eng8.buttonText.setPosition(70, 360);
        properties["8공학관"] = eng8;

        Property student;
        student.name = "학생회관";
        student.price = 500;
        student.maxInterest = 100;
        student.owned = false;
        student.buttonArea = sf::FloatRect(234, 352, 135, 41);
        student.buttonText.setFont(font);
        student.buttonText.setString(formatMoney(student.price));
        student.buttonText.setCharacterSize(14);
        student.buttonText.setFillColor(sf::Color::Black);
        student.buttonText.setPosition(270, 360);
        properties["학생회관"] = student;

        Property challenge;
        challenge.name = "챌린지하우스";
        challenge.price = 5000;
        challenge.maxInterest = 4500;
        challenge.owned = false;
        challenge.buttonArea = sf::FloatRect(38, 588, 135, 41);
        challenge.buttonText.setFont(font);
        challenge.buttonText.setString(formatMoney(challenge.price));
        challenge.buttonText.setCharacterSize(14);
        challenge.buttonText.setFillColor(sf::Color::Black);
        challenge.buttonText.setPosition(70, 605);
        properties["챌린지하우스"] = challenge;

        Property library;
        library.name = "도서관";
        library.price = 2500;
        library.maxInterest = 1800;
        library.owned = false;
        library.buttonArea = sf::FloatRect(234, 588, 135, 41);
        library.buttonText.setFont(font);
        library.buttonText.setString(formatMoney(library.price));
        library.buttonText.setCharacterSize(14);
        library.buttonText.setFillColor(sf::Color::Black);
        library.buttonText.setPosition(270, 605);
        properties["도서관"] = library;

        return true;
    }

    int getTotalPropertyValue() const {
        int totalValue = 0;
        for (const auto& pair : properties) {
            if (pair.second.owned) {
                totalValue += pair.second.price;
            }
        }
        return totalValue;
    }

    int getTotalInterest() const {
        int totalInterest = 0;
        for (const auto& pair : properties) {
            if (pair.second.owned) {
                totalInterest += pair.second.maxInterest;
            }
        }
        return totalInterest;
    }

    int getOwnedPropertyCount() const {
        int count = 0;
        for (const auto& pair : properties) {
            if (pair.second.owned) {
                count++;
            }
        }
        return count;
    }

    bool handleClick(sf::Vector2f mousePos, MoneyDisplay& moneyDisplay) {
        for (auto& pair : properties) {
            Property& prop = pair.second;
            if (prop.buttonArea.contains(mousePos)) {
                if (!prop.owned) {
                    if (moneyDisplay.spendMoney(prop.price)) {
                        prop.owned = true;
                        prop.buttonText.setString(L"판매하기");
                        prop.buttonText.setFillColor(sf::Color(255, 0, 0));
                        std::cout << prop.name << " 구매 완료! " << prop.price << "골드 지불" << std::endl;
                        return true;
                    }
                    else {
                        std::cout << "골드가 부족합니다!" << std::endl;
                    }
                }
                else {
                    int sellPrice = prop.price + prop.maxInterest;
                    int profit = prop.maxInterest; // 실제 수익은 이자 부분
                    totalSalesProfit += profit; // 수익 누적

                    moneyDisplay.addMoney(sellPrice);
                    prop.owned = false;
                    prop.buttonText.setString(formatMoney(prop.price));
                    prop.buttonText.setFillColor(sf::Color(0, 0, 0));

                    std::cout << prop.name << " 판매 완료! " << sellPrice << "골드 획득 (수익: " << profit << "골드)" << std::endl;
                    std::cout << " 역대 부동산 판매 총 수익: " << totalSalesProfit << "골드" << std::endl;
                    return true;
                }
            }
        }
        return false;
    }

    void draw(sf::RenderWindow& window) {
        window.draw(buildingSprite);
        for (const auto& pair : properties) {
            window.draw(pair.second.buttonText);
        }
    }
};

class KNUPowerSystem {
private:
    sf::Font font;
    sf::Texture knuTexture;
    sf::Sprite knuSprite;
    sf::Sprite knuCharSprite;

    int level = 1;
    int goldPerClick = 1;
    int levelUpCost = 100;

    sf::RectangleShape levelUpButton;
    sf::Text levelUpText;
    sf::Text levelText;
    sf::Text goldLevelText;
    sf::Text propertyLevelText;

    // 친구별 개별 보너스 표시 텍스트들
    sf::Text myeongjunBonusText;
    sf::Text ahyeonBonusText;
    sf::Text jinseoBonusText;

public:
    bool init(sf::RenderWindow& window) {
        if (!font.loadFromFile("NotoSansKR-SemiBold.ttf")) {
            std::cerr << "폰트 로딩 실패!" << std::endl;
            return false;
        }

        if (!knuTexture.loadFromFile("KUN power_bg.png")) {
            std::cerr << "KUN power_bg.png 로딩 실패!" << std::endl;
            return false;
        }

        knuSprite.setTexture(knuTexture);
        float scaleX = window.getSize().x / static_cast<float>(knuTexture.getSize().x);
        float scaleY = window.getSize().y / static_cast<float>(knuTexture.getSize().y);
        knuSprite.setScale(scaleX, scaleY);

        knuCharSprite.setScale(0.4f, 0.4f);
        knuCharSprite.setPosition(142.f, 498.f);

        levelUpButton.setSize(sf::Vector2f(140.f, 27.f));
        levelUpButton.setPosition(220.f, 235.f);
        levelUpButton.setFillColor(sf::Color(255, 195, 91));
        levelUpButton.setOutlineColor(sf::Color(255, 195, 91));
        levelUpButton.setOutlineThickness(2.f);

        levelUpText.setFont(font);
        levelUpText.setString(L"레벨업 (" + formatMoney(levelUpCost) + L")");
        levelUpText.setCharacterSize(15);
        levelUpText.setFillColor(sf::Color::Black);
        levelUpText.setPosition(235.f, 243.f);

        levelText.setFont(font);
        levelText.setString(L"Lv" + std::to_wstring(level));
        levelText.setCharacterSize(24);
        levelText.setFillColor(sf::Color(88, 74, 40));
        levelText.setPosition(195.f, 190.f);

        goldLevelText.setFont(font);
        goldLevelText.setString(L" 1"); // 초기값은 1
        goldLevelText.setCharacterSize(18);
        goldLevelText.setFillColor(sf::Color(48, 42, 27));
        goldLevelText.setPosition(140.f, 305.f);

        propertyLevelText.setFont(font);
        propertyLevelText.setString(L"");
        propertyLevelText.setCharacterSize(18);
        propertyLevelText.setFillColor(sf::Color(48, 42, 27));
        propertyLevelText.setPosition(157.f, 355.f);

        // 명준 보너스 텍스트 초기화 (0.1%)
        myeongjunBonusText.setFont(font);
        myeongjunBonusText.setString(L"");
        myeongjunBonusText.setCharacterSize(12);
        myeongjunBonusText.setFillColor(sf::Color(120, 84, 35));
        myeongjunBonusText.setPosition(122.f, 511.f);

        // 아현 보너스 텍스트 초기화 (0.3%)
        ahyeonBonusText.setFont(font);
        ahyeonBonusText.setString(L"");
        ahyeonBonusText.setCharacterSize(12);
        ahyeonBonusText.setFillColor(sf::Color(120, 84, 35));
        ahyeonBonusText.setPosition(290.f, 511.f);

        // 진서 보너스 텍스트 초기화 (0.5%)
        jinseoBonusText.setFont(font);
        jinseoBonusText.setString(L"");
        jinseoBonusText.setCharacterSize(12);
        jinseoBonusText.setFillColor(sf::Color(120, 84, 35));
        jinseoBonusText.setPosition(122.f, 591.f);

        return true;
    }

    bool tryLevelUp(MoneyDisplay& moneyDisplay) {
        if (moneyDisplay.spendMoney(levelUpCost)) {
            level++;
            goldPerClick = level;
            levelUpCost = 100 * level;

            levelText.setString(L"Lv" + std::to_wstring(level));
            levelUpText.setString(L"레벨업 (" + formatMoney(levelUpCost) + L")");

            return true;
        }
        return false;
    }

    // 개별 친구 보너스 계산 함수 (차등 보너스율 적용)
    int calculateIndividualFriendBonus(int currentGold, int friendLevel, int friendIndex) {
        if (friendLevel >= 20) {
            double bonusRate = 0.0;
            switch (friendIndex) {
            case 0: bonusRate = 0.001; break; // 명준: 0.1
            case 1: bonusRate = 0.003; break; // 아현: 0.3%
            case 2: bonusRate = 0.005; break; // 진서: 0.5%
            }
            return static_cast<int>(currentGold * bonusRate);
        }
        return 0;
    }

    // 전체 친구 보너스 계산 함수 (자산 계산용)
    int calculateFriendBonus(int currentGold, int friend1Level, int friend2Level, int friend3Level) {
        int totalBonus = 0;

        // 명준 보너스 (0.1%)
        if (friend1Level >= 20) {
            totalBonus += static_cast<int>(currentGold * 0.001);
        }

        // 아현 보너스 (0.3%)
        if (friend2Level >= 20) {
            totalBonus += static_cast<int>(currentGold * 0.003);
        }

        // 진서 보너스 (0.5%)
        if (friend3Level >= 20) {
            totalBonus += static_cast<int>(currentGold * 0.005);
        }

        return totalBonus;
    }

    // 친구별 보너스 텍스트 업데이트 함수
    void updateFriendBonusDisplay(int currentGold, int friend1Level, int friend2Level, int friend3Level) {
        // 명준 보너스 표시 (0.1%)
        if (friend1Level >= 20) {
            int myeongjunBonus = calculateIndividualFriendBonus(currentGold, friend1Level, 0);
            std::wstring myeongjunText = formatMoney(myeongjunBonus);
            myeongjunBonusText.setString(myeongjunText);
        }
        else {
            myeongjunBonusText.setString(L"");
        }

        // 아현 보너스 표시 (0.3%)
        if (friend2Level >= 20) {
            int ahyeonBonus = calculateIndividualFriendBonus(currentGold, friend2Level, 1);
            std::wstring ahyeonText = formatMoney(ahyeonBonus);
            ahyeonBonusText.setString(ahyeonText);
        }
        else {
            ahyeonBonusText.setString(L"");
        }

        // 진서 보너스 표시 (0.5%)
        if (friend3Level >= 20) {
            int jinseoBonus = calculateIndividualFriendBonus(currentGold, friend3Level, 2);
            std::wstring jinseoText = formatMoney(jinseoBonus);
            jinseoBonusText.setString(jinseoText);
        }
        else {
            jinseoBonusText.setString(L"");
        }
    }

    // 부동산 클릭 보너스 계산 (부동산 개수 * 0.5%)
    int calculatePropertyClickBonus(int baseGold, int propertyCount) {
        return static_cast<int>(baseGold * propertyCount * 0.005); // 0.5% = 0.005
    }

    // 전체 클릭당 골드 계산 (기본 + 친구 + 부동산)
    int getGoldPerClick(bool showMyeongjun, bool showAhyeon, bool showJinseo, int propertyCount) {
        int baseGold = goldPerClick;

        // 친구 보너스 (기존 5% 보너스)
        int friendCount = 0;
        if (showMyeongjun) friendCount++;
        if (showAhyeon) friendCount++;
        if (showJinseo) friendCount++;
        int friendBonus = static_cast<int>(baseGold * friendCount * 0.05);

        // 부동산 클릭 보너스 (부동산 개수 * 0.5%)
        int propertyBonus = calculatePropertyClickBonus(baseGold, propertyCount);

        return baseGold + friendBonus + propertyBonus;
    }

    // 클릭당 골드 및 부동산 판매 수익 표시 업데이트 함수
    void updateDisplays(bool showMyeongjun, bool showAhyeon, bool showJinseo, int propertyCount, int salesProfit) {
        // 총 클릭당 골드 계산 및 표시
        int totalClickGold = getGoldPerClick(showMyeongjun, showAhyeon, showJinseo, propertyCount);
        goldLevelText.setString(L" " + std::to_wstring(totalClickGold));

        // 역대 부동산 판매 수익 표시
        propertyLevelText.setString(L" " + std::to_wstring(salesProfit));
    }

    bool handleClick(sf::Vector2f mousePos, MoneyDisplay& moneyDisplay) {
        if (levelUpButton.getGlobalBounds().contains(mousePos)) {
            return tryLevelUp(moneyDisplay);
        }
        return false;
    }

    int getLevel() const {
        return level;
    }

    int getGoldPerClick() const {
        return goldPerClick;
    }

    void draw(sf::RenderWindow& window) {
        window.draw(knuSprite);
        window.draw(knuCharSprite);
        window.draw(levelUpButton);
        window.draw(levelUpText);
        window.draw(levelText);
        window.draw(goldLevelText);
        window.draw(propertyLevelText);

        // 친구별 개별 보너스 텍스트 그리기
        window.draw(myeongjunBonusText);
        window.draw(ahyeonBonusText);
        window.draw(jinseoBonusText);
    }
};

class FriendSystem {
public:
    struct Friend {
        std::string name;
        int purchasePrice;
        int level;
        int levelUpCost;
        int incomePerSecond;
        bool owned;
        sf::FloatRect clickArea;
        sf::Text displayText;
        sf::Text costText;
    };

private:
    sf::Font friendFont;
    std::vector<Friend> friends;
    sf::Clock incomeTimer;

public:
    bool init() {
        if (!friendFont.loadFromFile("NotoSansKR-SemiBold.ttf")) {
            return false;
        }

        friends.resize(3);

        // 명준 (Friend 0) - 0.1% 보너스
        friends[0].name = "명준";
        friends[0].purchasePrice = 1000;
        friends[0].level = 0;
        friends[0].levelUpCost = 2000;
        friends[0].incomePerSecond = 0;
        friends[0].owned = false;
        friends[0].clickArea = sf::FloatRect(29, 294, 140, 45);

        friends[0].displayText.setFont(friendFont);
        friends[0].displayText.setString(formatMoney(friends[0].purchasePrice));
        friends[0].displayText.setCharacterSize(20);
        friends[0].displayText.setFillColor(sf::Color::Black);
        sf::FloatRect rect1 = friends[0].displayText.getLocalBounds();
        friends[0].displayText.setOrigin(rect1.left + rect1.width / 2, rect1.top + rect1.height / 2);
        friends[0].displayText.setPosition(29.f + 70.f, 294.f + 15.f);

        friends[0].costText.setFont(friendFont);
        friends[0].costText.setString(L"");
        friends[0].costText.setCharacterSize(14);
        friends[0].costText.setFillColor(sf::Color::Red);
        friends[0].costText.setPosition(29.f + 10.f, 294.f + 30.f);

        // 아현 (Friend 1) - 0.3% 보너스
        friends[1].name = "아현";
        friends[1].purchasePrice = 10000;
        friends[1].level = 0;
        friends[1].levelUpCost = 10000;
        friends[1].incomePerSecond = 0;
        friends[1].owned = false;
        friends[1].clickArea = sf::FloatRect(222, 292, 137, 46);

        friends[1].displayText.setFont(friendFont);
        friends[1].displayText.setString(formatMoney(friends[1].purchasePrice));
        friends[1].displayText.setCharacterSize(20);
        friends[1].displayText.setFillColor(sf::Color::Black);
        sf::FloatRect rect2 = friends[1].displayText.getLocalBounds();
        friends[1].displayText.setOrigin(rect2.left + rect2.width / 2, rect2.top + rect2.height / 2);
        friends[1].displayText.setPosition(221.f + 68.f, 292.f + 15.f);

        friends[1].costText.setFont(friendFont);
        friends[1].costText.setString(L"");
        friends[1].costText.setCharacterSize(14);
        friends[1].costText.setFillColor(sf::Color::Red);
        friends[1].costText.setPosition(222.f + 10.f, 292.f + 30.f);

        // 진서 (Friend 2) - 0.5% 보너스
        friends[2].name = "진서";
        friends[2].purchasePrice = 100000;
        friends[2].level = 0;
        friends[2].levelUpCost = 100000;
        friends[2].incomePerSecond = 0;
        friends[2].owned = false;
        friends[2].clickArea = sf::FloatRect(31, 496, 135, 45);

        friends[2].displayText.setFont(friendFont);
        friends[2].displayText.setString(formatMoney(friends[2].purchasePrice));
        friends[2].displayText.setCharacterSize(20);
        friends[2].displayText.setFillColor(sf::Color::Black);
        sf::FloatRect rect3 = friends[2].displayText.getLocalBounds();
        friends[2].displayText.setOrigin(rect3.left + rect3.width / 2, rect3.top + rect3.height / 2);
        friends[2].displayText.setPosition(27.f + 67.f, 496.f + 15.f);

        friends[2].costText.setFont(friendFont);
        friends[2].costText.setString(L"");
        friends[2].costText.setCharacterSize(14);
        friends[2].costText.setFillColor(sf::Color::Red);
        friends[2].costText.setPosition(31.f + 10.f, 496.f + 30.f);

        return true;
    }

    bool handleClick(sf::Vector2f mousePos, MoneyDisplay& moneyDisplay) {
        for (size_t i = 0; i < friends.size(); i++) {
            if (friends[i].clickArea.contains(mousePos)) {
                if (!friends[i].owned) {
                    if (moneyDisplay.spendMoney(friends[i].purchasePrice)) {
                        friends[i].owned = true;
                        friends[i].level = 1;

                        if (i == 0) friends[i].incomePerSecond = 10;
                        else if (i == 1) friends[i].incomePerSecond = 100;
                        else if (i == 2) friends[i].incomePerSecond = 1000;

                        updateDisplayText(i);
                        std::cout << friends[i].name << " 구매 완료! " << friends[i].purchasePrice << "골드 지불" << std::endl;
                        return true;
                    }
                    else {
                        std::cout << "골드가 부족합니다!" << std::endl;
                    }
                }
                else {
                    if (moneyDisplay.spendMoney(friends[i].levelUpCost)) {
                        friends[i].level++;

                        if (i == 0) {
                            friends[i].incomePerSecond += 10;
                            friends[i].levelUpCost += 1000;
                        }
                        else if (i == 1) {
                            friends[i].incomePerSecond += 100;
                            friends[i].levelUpCost += 10000;
                        }
                        else if (i == 2) {
                            if (friends[i].level == 2) {
                                friends[i].incomePerSecond = 2000;
                            }
                            else {
                                friends[i].incomePerSecond += 2000;
                            }
                            friends[i].levelUpCost += 100000;
                        }

                        updateDisplayText(i);
                        std::cout << friends[i].name << " 레벨업! 현재 레벨: " << friends[i].level << std::endl;

                        // 20레벨 달성 시 특별 메시지 (차등 보너스율 표시)
                        if (friends[i].level == 20) {
                            std::string bonusRate = "";
                            if (i == 0) bonusRate = "0.1%";
                            else if (i == 1) bonusRate = "0.3%";
                            else if (i == 2) bonusRate = "0.5%";

                            std::cout << " 축하합니다! " << friends[i].name << "이(가) 20레벨에 달성했습니다!" << std::endl;
                            std::cout << " " << friends[i].name << "의 " << bonusRate << " 보너스가 활성화됩니다!" << std::endl;
                        }

                        return true;
                    }
                    else {
                        std::cout << "레벨업 비용이 부족합니다!" << std::endl;
                    }
                }
                break;
            }
        }
        return false;
    }

    void updateDisplayText(int friendIndex) {
        if (friendIndex >= 0 && friendIndex < static_cast<int>(friends.size()) && friends[friendIndex].owned) {
            std::wstring levelText = L"Lv" + std::to_wstring(friends[friendIndex].level);
            friends[friendIndex].displayText.setString(levelText);

            // 20레벨 이상이면 색상 변경
            if (friends[friendIndex].level >= 20) {
                friends[friendIndex].displayText.setFillColor(sf::Color(255, 215, 0)); // 골드 색상
            }
            else {
                friends[friendIndex].displayText.setFillColor(sf::Color::Blue);
            }

            std::wstring costText = L"레벨업: " + formatMoney(friends[friendIndex].levelUpCost);
            friends[friendIndex].costText.setString(costText);

            std::wcout << friends[friendIndex].name.c_str() << L" - 레벨: " << friends[friendIndex].level
                << L", 초당 수익: " << friends[friendIndex].incomePerSecond
                << L", 다음 레벨업 비용: " << friends[friendIndex].levelUpCost << std::endl;
        }
    }

    void updateIncome(MoneyDisplay& moneyDisplay) {
        if (incomeTimer.getElapsedTime().asSeconds() >= 1.0f) {
            int totalIncome = 0;
            for (const auto& friendObj : friends) {
                if (friendObj.owned) {
                    totalIncome += friendObj.incomePerSecond;
                }
            }

            if (totalIncome > 0) {
                moneyDisplay.addMoney(totalIncome);
                std::cout << "친구들로부터 " << totalIncome << "골드 수익!" << std::endl;
            }

            incomeTimer.restart();
        }
    }

    bool isFriendOwned(int friendIndex) const {
        if (friendIndex >= 0 && friendIndex < static_cast<int>(friends.size())) {
            return friends[friendIndex].owned;
        }
        return false;
    }

    // 친구 레벨 반환 함수
    int getFriendLevel(int friendIndex) const {
        if (friendIndex >= 0 && friendIndex < static_cast<int>(friends.size())) {
            return friends[friendIndex].level;
        }
        return 0;
    }

    // 친구 이름 반환 함수 추가
    std::string getFriendName(int friendIndex) const {
        if (friendIndex >= 0 && friendIndex < static_cast<int>(friends.size())) {
            return friends[friendIndex].name;
        }
        return "";
    }

    int getTotalFriendIncome() const {
        int totalIncome = 0;
        for (const auto& friendObj : friends) {
            if (friendObj.owned) {
                totalIncome += friendObj.incomePerSecond;
            }
        }
        return totalIncome;
    }

    int getOwnedFriendCount() const {
        int count = 0;
        for (const auto& friendObj : friends) {
            if (friendObj.owned) {
                count++;
            }
        }
        return count;
    }

    void printFriendInfo() const {
        std::cout << "\n=== 친구 정보 (차등 보너스율) ===" << std::endl;
        for (size_t i = 0; i < friends.size(); i++) {
            if (friends[i].owned) {
                std::string bonusRate = "";
                if (i == 0) bonusRate = "0.1%";
                else if (i == 1) bonusRate = "0.3%";
                else if (i == 2) bonusRate = "0.5%";

                std::cout << friends[i].name << " - Lv" << friends[i].level
                    << ", 초당 " << friends[i].incomePerSecond << "골드"
                    << ", 레벨업 비용: " << friends[i].levelUpCost << "골드";

                if (friends[i].level >= 20) {
                    std::cout << " [ 20레벨 달성! " << bonusRate << " 보너스 활성화]";
                }
                else {
                    std::cout << " [20레벨 달성 시 " << bonusRate << " 보너스]";
                }
                std::cout << std::endl;
            }
            else {
                std::string bonusRate = "";
                if (i == 0) bonusRate = "0.1%";
                else if (i == 1) bonusRate = "0.3%";
                else if (i == 2) bonusRate = "0.5%";

                std::cout << friends[i].name << " - 미구매 (구매 비용: " << friends[i].purchasePrice
                    << "골드, 20레벨 달성 시 " << bonusRate << " 보너스)" << std::endl;
            }
        }
        std::cout << "==========================================\n" << std::endl;
    }

    void draw(sf::RenderWindow& window) {
        for (const auto& friendObj : friends) {
            window.draw(friendObj.displayText);
            if (friendObj.owned) {
                window.draw(friendObj.costText);
            }
        }
    }
};

class AchievementSystem {
private:
    sf::Texture medalTexture;
    sf::Sprite medalSprite;
    sf::Texture rewardButtonTexture;
    sf::Sprite rewardButtonSprite;

    // 업적 상태 (각 카테고리별 5개씩)
    std::vector<bool> clickAchievements;    // 클릭 업적
    std::vector<bool> goldAchievements;     // 골드 업적  
    std::vector<bool> graduationAchievements; // 졸업 업적
    std::vector<bool> beggarAchievements;   // 구걸 업적
    std::vector<bool> blueDrinkAchievements; // 파란 드링크 사용 업적
    std::vector<bool> redDrinkAchievements;  // 빨간 드링크 사용 업적

    // 업적 조건
    std::vector<int> clickTargets = { 10, 100, 1000, 10000, 100000 };
    std::vector<int> goldTargets = { 10, 100, 1000, 10000, 100000 };
    std::vector<int> graduationTargets = { 10, 20, 100, 200, 250 };
    std::vector<int> beggarTargets = { 1, 2, 3, 4, 5 };
    std::vector<int> blueDrinkTargets = { 1, 2, 3, 4, 5 }; // 파란 드링크 사용 횟수
    std::vector<int> redDrinkTargets = { 1, 2, 3, 4, 5 };  // 빨간 드링크 사용 횟수

    // 각 카테고리별 메달 개수 추적
    int clickMedals = 0;
    int goldMedals = 0;
    int graduationMedals = 0;
    int beggarMedals = 0;
    int blueDrinkMedals = 0;
    int redDrinkMedals = 0;

    // 각 카테고리별 보상 수령 상태
    int clickRewardsClaimed = 0;
    int goldRewardsClaimed = 0;
    int graduationRewardsClaimed = 0;
    int beggarRewardsClaimed = 0;
    int blueDrinkRewardsClaimed = 0;
    int redDrinkRewardsClaimed = 0;

    // 에너지 드링크 관련
    int blueDrinks = 0;
    int redDrinks = 0;

    // 에너지 드링크 사용 횟수 추적
    int blueDrinksUsed = 0;
    int redDrinksUsed = 0;

    // 에너지 드링크 효과 관련
    sf::Clock blueEffectTimer;
    sf::Clock redEffectTimer;
    bool blueEffectActive = false;
    bool redEffectActive = false;

    // 메달 위치 설정 변수들
    float medalStartX = 78.0f;
    float medalStartY = 205.0f;
    float medalSpacing = 27.0f;
    float medalRowSpacing = 78.0f;

    // 보상 버튼 위치 설정 변수들
    float buttonStartX = 279.0f;
    float buttonStartY = 179.0f;
    float buttonRowSpacing = 78.0f;
    float buttonWidth = 50.0f;
    float buttonHeight = 50.0f;

public:
    bool init() {
        if (!medalTexture.loadFromFile("Achieve_medal.png")) {
            std::cerr << "Achieve_medal.png 로딩 실패!" << std::endl;
            return false;
        }

        if (!rewardButtonTexture.loadFromFile("Achieve_button_rewarding.png")) {
            std::cerr << "Achieve_button_rewarding.png 로딩 실패!" << std::endl;
            return false;
        }

        medalSprite.setTexture(medalTexture);
        medalSprite.setScale(0.6f, 0.6f);

        rewardButtonSprite.setTexture(rewardButtonTexture);

        // 업적 상태 초기화 (각 5개씩)
        clickAchievements.resize(5, false);
        goldAchievements.resize(5, false);
        graduationAchievements.resize(5, false);
        beggarAchievements.resize(5, false);
        blueDrinkAchievements.resize(5, false);
        redDrinkAchievements.resize(5, false);

        return true;
    }

    void updateAchievements(int goldPerClick, int friendIncome, int knuLevel, int friendCount) {
        // 클릭 업적 체크
        for (size_t i = 0; i < clickTargets.size(); i++) {
            if (goldPerClick >= clickTargets[i]) {
                if (!clickAchievements[i]) {
                    clickAchievements[i] = true;
                    clickMedals++;
                    std::cout << "클릭 업적 달성! 클릭당 " << clickTargets[i] << "골드 (보상 버튼을 클릭하세요!)" << std::endl;
                }
            }
        }

        // 골드 업적 체크 (친구들 초당 수익)
        for (size_t i = 0; i < goldTargets.size(); i++) {
            if (friendIncome >= goldTargets[i]) {
                if (!goldAchievements[i]) {
                    goldAchievements[i] = true;
                    goldMedals++;
                    std::cout << "골드 업적 달성! 초당 " << goldTargets[i] << "골드 (보상 버튼을 클릭하세요!)" << std::endl;
                }
            }
        }

        // 졸업 업적 체크 (KNU 레벨)
        for (size_t i = 0; i < graduationTargets.size(); i++) {
            if (knuLevel >= graduationTargets[i]) {
                if (!graduationAchievements[i]) {
                    graduationAchievements[i] = true;
                    graduationMedals++;
                    std::cout << "졸업 업적 달성! KNU 레벨 " << graduationTargets[i] << " (보상 버튼을 클릭하세요!)" << std::endl;
                }
            }
        }

        // 구걸 업적 체크 (친구 구매 개수)
        for (size_t i = 0; i < beggarTargets.size(); i++) {
            if (friendCount >= beggarTargets[i]) {
                if (!beggarAchievements[i]) {
                    beggarAchievements[i] = true;
                    beggarMedals++;
                    std::cout << "구걸 업적 달성! 친구 " << beggarTargets[i] << "명 구매 (보상 버튼을 클릭하세요!)" << std::endl;
                }
            }
        }

        // 파란 드링크 사용 업적 체크
        for (size_t i = 0; i < blueDrinkTargets.size(); i++) {
            if (blueDrinksUsed >= blueDrinkTargets[i]) {
                if (!blueDrinkAchievements[i]) {
                    blueDrinkAchievements[i] = true;
                    blueDrinkMedals++;
                    std::cout << "파란 드링크 업적 달성! " << blueDrinkTargets[i] << "회 사용 (보상 버튼을 클릭하세요!)" << std::endl;
                }
            }
        }

        // 빨간 드링크 사용 업적 체크
        for (size_t i = 0; i < redDrinkTargets.size(); i++) {
            if (redDrinksUsed >= redDrinkTargets[i]) {
                if (!redDrinkAchievements[i]) {
                    redDrinkAchievements[i] = true;
                    redDrinkMedals++;
                    std::cout << "빨간 드링크 업적 달성! " << redDrinkTargets[i] << "회 사용 (보상 버튼을 클릭하세요!)" << std::endl;
                }
            }
        }
    }

    bool handleRewardButtonClick(sf::Vector2f mousePos) {
        std::cout << "[보상 버튼 클릭 체크] 마우스 위치: (" << mousePos.x << ", " << mousePos.y << ")" << std::endl;

        // 클릭 업적 보상 버튼 (첫 번째 줄)
        sf::FloatRect clickButtonArea(buttonStartX, buttonStartY, buttonWidth, buttonHeight);
        if (clickButtonArea.contains(mousePos) && clickMedals > clickRewardsClaimed) {
            std::cout << "클릭 업적 보상 버튼 클릭됨!" << std::endl;
            int newRewards = clickMedals - clickRewardsClaimed;
            for (int i = 0; i < newRewards; i++) {
                if (clickRewardsClaimed + i + 1 <= 3) {
                    blueDrinks++;
                    std::cout << "클릭 업적 보상: 파란 에너지 드링크 획득! 현재 개수: " << blueDrinks << std::endl;
                }
                else {
                    redDrinks++;
                    std::cout << "클릭 업적 보상: 빨간 에너지 드링크 획득! 현재 개수: " << redDrinks << std::endl;
                }
            }
            clickRewardsClaimed = clickMedals;
            return true;
        }

        // 골드 업적 보상 버튼 (두 번째 줄)
        sf::FloatRect goldButtonArea(buttonStartX, buttonStartY + buttonRowSpacing, buttonWidth, buttonHeight);
        if (goldButtonArea.contains(mousePos) && goldMedals > goldRewardsClaimed) {
            std::cout << "골드 업적 보상 버튼 클릭됨!" << std::endl;
            int newRewards = goldMedals - goldRewardsClaimed;
            for (int i = 0; i < newRewards; i++) {
                if (goldRewardsClaimed + i + 1 <= 3) {
                    blueDrinks++;
                    std::cout << "골드 업적 보상: 파란 에너지 드링크 획득! 현재 개수: " << blueDrinks << std::endl;
                }
                else {
                    redDrinks++;
                    std::cout << "골드 업적 보상: 빨간 에너지 드링크 획득! 현재 개수: " << redDrinks << std::endl;
                }
            }
            goldRewardsClaimed = goldMedals;
            return true;
        }

        // 졸업 업적 보상 버튼 (세 번째 줄)
        sf::FloatRect graduationButtonArea(buttonStartX, buttonStartY + (2 * buttonRowSpacing), buttonWidth, buttonHeight);
        if (graduationButtonArea.contains(mousePos) && graduationMedals > graduationRewardsClaimed) {
            std::cout << "졸업 업적 보상 버튼 클릭됨!" << std::endl;
            int newRewards = graduationMedals - graduationRewardsClaimed;
            for (int i = 0; i < newRewards; i++) {
                if (graduationRewardsClaimed + i + 1 <= 3) {
                    blueDrinks++;
                    std::cout << "졸업 업적 보상: 파란 에너지 드링크 획득! 현재 개수: " << blueDrinks << std::endl;
                }
                else {
                    redDrinks++;
                    std::cout << "졸업 업적 보상: 빨간 에너지 드링크 획득! 현재 개수: " << redDrinks << std::endl;
                }
            }
            graduationRewardsClaimed = graduationMedals;
            return true;
        }

        // 구걸 업적 보상 버튼 (네 번째 줄)
        sf::FloatRect beggarButtonArea(buttonStartX, buttonStartY + (3 * buttonRowSpacing), buttonWidth, buttonHeight);
        if (beggarButtonArea.contains(mousePos) && beggarMedals > beggarRewardsClaimed) {
            std::cout << "구걸 업적 보상 버튼 클릭됨!" << std::endl;
            int newRewards = beggarMedals - beggarRewardsClaimed;
            for (int i = 0; i < newRewards; i++) {
                if (beggarRewardsClaimed + i + 1 <= 3) {
                    blueDrinks++;
                    std::cout << "구걸 업적 보상: 파란 에너지 드링크 획득! 현재 개수: " << blueDrinks << std::endl;
                }
                else {
                    redDrinks++;
                    std::cout << "구걸 업적 보상: 빨간 에너지 드링크 획득! 현재 개수: " << redDrinks << std::endl;
                }
            }
            beggarRewardsClaimed = beggarMedals;
            return true;
        }

        // 파란 드링크 사용 업적 보상 버튼 (다섯 번째 줄)
        sf::FloatRect blueDrinkButtonArea(buttonStartX, buttonStartY + (4 * buttonRowSpacing), buttonWidth, buttonHeight);
        if (blueDrinkButtonArea.contains(mousePos) && blueDrinkMedals > blueDrinkRewardsClaimed) {
            std::cout << "파란 드링크 사용 업적 보상 버튼 클릭됨!" << std::endl;
            int newRewards = blueDrinkMedals - blueDrinkRewardsClaimed;
            for (int i = 0; i < newRewards; i++) {
                blueDrinks++;
                std::cout << "파란 드링크 사용 업적 보상: 파란 에너지 드링크 획득! 현재 개수: " << blueDrinks << std::endl;
            }
            blueDrinkRewardsClaimed = blueDrinkMedals;
            return true;
        }

        // 빨간 드링크 사용 업적 보상 버튼 (여섯 번째 줄)
        sf::FloatRect redDrinkButtonArea(buttonStartX, buttonStartY + (5 * buttonRowSpacing), buttonWidth, buttonHeight);
        if (redDrinkButtonArea.contains(mousePos) && redDrinkMedals > redDrinkRewardsClaimed) {
            std::cout << "빨간 드링크 사용 업적 보상 버튼 클릭됨!" << std::endl;
            int newRewards = redDrinkMedals - redDrinkRewardsClaimed;
            for (int i = 0; i < newRewards; i++) {
                redDrinks++;
                std::cout << "빨간 드링크 사용 업적 보상: 빨간 에너지 드링크 획득! 현재 개수: " << redDrinks << std::endl;
            }
            redDrinkRewardsClaimed = redDrinkMedals;
            return true;
        }

        return false;
    }

    void updateEffects() {
        // 파란 드링크 효과 시간 체크
        if (blueEffectActive && blueEffectTimer.getElapsedTime().asSeconds() >= 10.0f) {
            blueEffectActive = false;
            std::cout << "파란 에너지 드링크 효과 종료!" << std::endl;
        }

        // 빨간 드링크 효과 시간 체크
        if (redEffectActive && redEffectTimer.getElapsedTime().asSeconds() >= 10.0f) {
            redEffectActive = false;
            std::cout << "빨간 에너지 드링크 효과 종료!" << std::endl;
        }
    }

    bool handleDrinkClick(sf::Vector2f mousePos) {
        // 파란 드링크 클릭 영역 (x:65, y:55 주변)
        if (sf::FloatRect(60, 50, 20, 20).contains(mousePos) && blueDrinks > 0) {
            blueDrinks--;
            blueDrinksUsed++; // 사용 횟수 증가
            blueEffectActive = true;
            blueEffectTimer.restart();
            std::cout << "파란 에너지 드링크 사용! 10초간 골드 10배 효과 활성화! 남은 개수: " << blueDrinks << ", 총 사용 횟수: " << blueDrinksUsed << std::endl;
            return true;
        }

        // 빨간 드링크 클릭 영역 (x:140, y:55 주변)
        if (sf::FloatRect(135, 50, 20, 20).contains(mousePos) && redDrinks > 0) {
            redDrinks--;
            redDrinksUsed++; // 사용 횟수 증가
            redEffectActive = true;
            redEffectTimer.restart();
            std::cout << "빨간 에너지 드링크 사용! 10초간 골드 100배 효과 활성화! 남은 개수: " << redDrinks << ", 총 사용 횟수: " << redDrinksUsed << std::endl;
            return true;
        }

        return false;
    }

    int getGoldMultiplier() const {
        if (redEffectActive) return 100;
        if (blueEffectActive) return 10;
        return 1;
    }

    int getBlueDrinks() const {
        return blueDrinks;
    }

    int getRedDrinks() const {
        return redDrinks;
    }

    int getBlueDrinksUsed() const {
        return blueDrinksUsed;
    }

    int getRedDrinksUsed() const {
        return redDrinksUsed;
    }

    bool isBlueEffectActive() const {
        return blueEffectActive;
    }

    bool isRedEffectActive() const {
        return redEffectActive;
    }

    float getBlueEffectTimeLeft() const {
        if (!blueEffectActive) return 0.0f;
        return 10.0f - blueEffectTimer.getElapsedTime().asSeconds();
    }

    float getRedEffectTimeLeft() const {
        if (!redEffectActive) return 0.0f;
        return 10.0f - redEffectTimer.getElapsedTime().asSeconds();
    }

    void draw(sf::RenderWindow& window) {
        // 클릭 업적 메달 그리기 (첫 번째 줄)
        for (size_t i = 0; i < clickAchievements.size(); i++) {
            if (clickAchievements[i]) {
                medalSprite.setPosition(medalStartX + (i * medalSpacing), medalStartY);
                window.draw(medalSprite);
            }
        }

        // 골드 업적 메달 그리기 (두 번째 줄)
        for (size_t i = 0; i < goldAchievements.size(); i++) {
            if (goldAchievements[i]) {
                medalSprite.setPosition(medalStartX + (i * medalSpacing), medalStartY + medalRowSpacing);
                window.draw(medalSprite);
            }
        }

        // 졸업 업적 메달 그리기 (세 번째 줄)
        for (size_t i = 0; i < graduationAchievements.size(); i++) {
            if (graduationAchievements[i]) {
                medalSprite.setPosition(medalStartX + (i * medalSpacing), medalStartY + (2 * medalRowSpacing));
                window.draw(medalSprite);
            }
        }

        // 구걸 업적 메달 그리기 (네 번째 줄)
        for (size_t i = 0; i < beggarAchievements.size(); i++) {
            if (beggarAchievements[i]) {
                medalSprite.setPosition(medalStartX + (i * medalSpacing), medalStartY + (3 * medalRowSpacing));
                window.draw(medalSprite);
            }
        }

        // 파란 드링크 사용 업적 메달 그리기 (다섯 번째 줄)
        for (size_t i = 0; i < blueDrinkAchievements.size(); i++) {
            if (blueDrinkAchievements[i]) {
                medalSprite.setPosition(medalStartX + (i * medalSpacing), medalStartY + (4 * medalRowSpacing));
                window.draw(medalSprite);
            }
        }

        // 빨간 드링크 사용 업적 메달 그리기 (여섯 번째 줄)
        for (size_t i = 0; i < redDrinkAchievements.size(); i++) {
            if (redDrinkAchievements[i]) {
                medalSprite.setPosition(medalStartX + (i * medalSpacing), medalStartY + (5 * medalRowSpacing));
                window.draw(medalSprite);
            }
        }

        // 보상 버튼 그리기 (수령하지 않은 보상이 있을 때만)
        if (clickMedals > clickRewardsClaimed) {
            rewardButtonSprite.setPosition(buttonStartX, buttonStartY);
            window.draw(rewardButtonSprite);
        }
        if (goldMedals > goldRewardsClaimed) {
            rewardButtonSprite.setPosition(buttonStartX, buttonStartY + buttonRowSpacing);
            window.draw(rewardButtonSprite);
        }
        if (graduationMedals > graduationRewardsClaimed) {
            rewardButtonSprite.setPosition(buttonStartX, buttonStartY + (2 * buttonRowSpacing));
            window.draw(rewardButtonSprite);
        }
        if (beggarMedals > beggarRewardsClaimed) {
            rewardButtonSprite.setPosition(buttonStartX, buttonStartY + (3 * buttonRowSpacing));
            window.draw(rewardButtonSprite);
        }
        if (blueDrinkMedals > blueDrinkRewardsClaimed) {
            rewardButtonSprite.setPosition(buttonStartX, buttonStartY + (4 * buttonRowSpacing));
            window.draw(rewardButtonSprite);
        }
        if (redDrinkMedals > redDrinkRewardsClaimed) {
            rewardButtonSprite.setPosition(buttonStartX, buttonStartY + (5 * buttonRowSpacing));
            window.draw(rewardButtonSprite);
        }
    }
};

class Game {
private:
    sf::RenderWindow window;
    MoneyDisplay moneyDisplay;
    Background background;
    Character character;
    RealEstate realEstate;
    KNUPowerSystem knuPowerSystem;
    FriendSystem friendSystem;
    AchievementSystem achievementSystem;

    sf::Texture mjTexture, ahTexture, jsTexture;
    sf::Sprite mjSprite, ahSprite, jsSprite;

    sf::RectangleShape clickableArea;

    sf::Text assetText;
    sf::Font assetFont;
    int totalAsset = 0;

    // 에너지 드링크 표시용 텍스트
    sf::Text blueDrinkText;
    sf::Text redDrinkText;
    sf::Text effectText; // 효과 표시용 텍스트

    std::string lastScene = "bg_playground.png";
    bool shouldShowCharacter = true;

    bool isCharacterBackground(const std::string& background) {
        return (background == "bg_dujeongStaion.png" ||
            background == "bg_google.png" ||
            background == "bg_playground.png" ||
            background == "bg_seouStation.png");
    }

public:
    Game() : window(sf::VideoMode(405, 720), "통합 게임 시스템 - 차등 보너스 + 업적 시스템") {}

    bool init() {
        std::locale::global(std::locale(""));
        std::wcout.imbue(std::locale(""));

        if (!moneyDisplay.init() || !background.init(window) || !character.init() ||
            !realEstate.init(window) || !knuPowerSystem.init(window) || !friendSystem.init() ||
            !achievementSystem.init())
            return false;

        clickableArea.setSize({ 180.f, 40.f });
        clickableArea.setPosition(203.f, 621.f);
        clickableArea.setOutlineColor(sf::Color::White);
        clickableArea.setOutlineThickness(2.f);

        if (!mjTexture.loadFromFile("friends_mj.png") ||
            !ahTexture.loadFromFile("friends_ah.png") ||
            !jsTexture.loadFromFile("friends_js.png")) {
            std::cerr << "친구 캐릭터 텍스처 로딩 실패!" << std::endl;
        }

        mjSprite.setTexture(mjTexture);
        ahSprite.setTexture(ahTexture);
        jsSprite.setTexture(jsTexture);

        mjSprite.setScale(0.5f, 0.5f);
        ahSprite.setScale(0.5f, 0.5f);
        jsSprite.setScale(0.5f, 0.5f);

        mjSprite.setPosition(100.f, 400.f);
        ahSprite.setPosition(220.f, 360.f);
        jsSprite.setPosition(160.f, 180.f);

        if (!assetFont.loadFromFile("NotoSansKR-SemiBold.ttf")) {
            std::cerr << "자산 폰트 로딩 실패!" << std::endl;
            return false;
        }
        assetText.setFont(assetFont);
        assetText.setCharacterSize(16);
        assetText.setFillColor(sf::Color::White);
        assetText.setPosition(window.getSize().x - 200.f, 10.f);

        // 에너지 드링크 텍스트 초기화
        blueDrinkText.setFont(assetFont);
        blueDrinkText.setCharacterSize(18);
        blueDrinkText.setFillColor(sf::Color::Blue);
        blueDrinkText.setPosition(65.f, 55.f); // 파란 드링크 위치 (x:65, y:55)

        redDrinkText.setFont(assetFont);
        redDrinkText.setCharacterSize(18);
        redDrinkText.setFillColor(sf::Color::Red);
        redDrinkText.setPosition(140.f, 55.f); // 빨간 드링크 위치 (x:140, y:55)

        // 효과 표시 텍스트 초기화
        effectText.setFont(assetFont);
        effectText.setCharacterSize(14);
        effectText.setFillColor(sf::Color::Yellow);
        effectText.setPosition(200.f, 55.f);

        updateTotalAsset();

        return true;
    }

    void updateTotalAsset() {
        int baseMoney = moneyDisplay.getMoney();

        // 친구별 차등 보너스 계산
        int friend1Level = friendSystem.getFriendLevel(1); // 명준
        int friend2Level = friendSystem.getFriendLevel(2); // 아현
        int friend3Level = friendSystem.getFriendLevel(2); // 진서

        int friendBonus = knuPowerSystem.calculateFriendBonus(baseMoney, friend1Level, friend2Level, friend3Level);

        int propertyValue = realEstate.getTotalPropertyValue();
        int propertyInterest = realEstate.getTotalInterest();
        int salesProfit = realEstate.getTotalSalesProfit();

        int friendIncome = friendSystem.getTotalFriendIncome();

        totalAsset = baseMoney + friendBonus + propertyValue + propertyInterest + salesProfit + (friendIncome * 60);

        std::wstring assetString = L"현재 자산 : " + formatMoney(totalAsset);
        assetText.setFillColor(sf::Color(100, 250, 50));
        assetText.setPosition(210.f, 30.f);
        assetText.setString(assetString);

        // KNU 파워 시스템 디스플레이 업데이트
        knuPowerSystem.updateDisplays(
            friendSystem.isFriendOwned(0),
            friendSystem.isFriendOwned(1),
            friendSystem.isFriendOwned(2),
            realEstate.getOwnedPropertyCount(),
            salesProfit
        );

        // 친구별 보너스 표시 업데이트
        knuPowerSystem.updateFriendBonusDisplay(baseMoney, friend1Level, friend2Level, friend3Level);

        // 에너지 드링크 개수 업데이트
        blueDrinkText.setString(std::to_string(achievementSystem.getBlueDrinks()));
        redDrinkText.setString(std::to_string(achievementSystem.getRedDrinks()));

        // 효과 표시 업데이트
        if (achievementSystem.isRedEffectActive()) {
            effectText.setString("빨간드링크 효과: " + std::to_string(static_cast<int>(achievementSystem.getRedEffectTimeLeft())) + "초");
            effectText.setFillColor(sf::Color::Red);
        }
        else if (achievementSystem.isBlueEffectActive()) {
            effectText.setString("파란드링크 효과: " + std::to_string(static_cast<int>(achievementSystem.getBlueEffectTimeLeft())) + "초");
            effectText.setFillColor(sf::Color::Blue);
        }
        else {
            effectText.setString("");
        }
    }

    void run() {
        while (window.isOpen()) {
            handleEvents();
            update();
            render();
        }
    }

private:
    void handleEvents() {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Space) {
                int baseGoldIncrease = knuPowerSystem.getGoldPerClick(
                    friendSystem.isFriendOwned(0),
                    friendSystem.isFriendOwned(1),
                    friendSystem.isFriendOwned(2),
                    realEstate.getOwnedPropertyCount()
                );

                // 에너지 드링크 효과 적용
                int multiplier = achievementSystem.getGoldMultiplier();
                int finalGoldIncrease = baseGoldIncrease * multiplier;

                moneyDisplay.increase(finalGoldIncrease);

                if (multiplier > 1) {
                    std::cout << "에너지 드링크 효과로 " << finalGoldIncrease << "골드 획득! (기본: " << baseGoldIncrease << " x " << multiplier << ")" << std::endl;
                }
            }

            if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::F) {
                friendSystem.printFriendInfo();
            }

            if (event.type == sf::Event::MouseButtonPressed && event.mouseButton.button == sf::Mouse::Left) {
                sf::Vector2f mousePos = window.mapPixelToCoords({ event.mouseButton.x, event.mouseButton.y });
                std::wcout << L"[클릭 위치] x: " << static_cast<int>(mousePos.x) << L", y: " << static_cast<int>(mousePos.y) << std::endl;

                std::string current = background.getCurrentFile();

                // 에너지 드링크 클릭 처리 (업적 화면이 아닐 때만)
                if (current != "Achieve_bg.png" && achievementSystem.handleDrinkClick(mousePos)) {
                    updateTotalAsset();
                    return; // 에너지 드링크를 클릭했으면 다른 클릭 처리는 하지 않음
                }

                // 업적 화면으로 전환하는 클릭 영역 (지정된 좌표들을 포함하는 영역)
                if (sf::FloatRect(14, 685, 15, 25).contains(mousePos)) {
                    lastScene = current;
                    background.load("Achieve_bg.png", window);
                    shouldShowCharacter = false;
                    std::cout << "업적 화면으로 전환!" << std::endl;
                }
                // 업적 화면에서 뒤로가기 (새로운 좌표 영역)
                else if (current == "Achieve_bg.png") {
                    if (sf::FloatRect(352, 17, 26, 19).contains(mousePos)) {
                        background.load(lastScene, window);
                        shouldShowCharacter = isCharacterBackground(lastScene);
                        std::cout << "업적 화면에서 뒤로가기!" << std::endl;
                    }
                    // 업적 화면에서 보상 버튼 클릭 처리
                    else if (achievementSystem.handleRewardButtonClick(mousePos)) {
                        updateTotalAsset();
                        std::cout << "보상 버튼 클릭 처리 완료!" << std::endl;
                    }
                }
                // KNU 파워 화면
                else if (current == "KUN power_bg.png") {
                    if (knuPowerSystem.handleClick(mousePos, moneyDisplay)) {
                        updateTotalAsset();
                    }
                    else if (sf::FloatRect(352, 92, 27, 23).contains(mousePos)) {
                        background.load(lastScene, window);
                        shouldShowCharacter = isCharacterBackground(lastScene);
                    }
                }
                // 부동산 화면
                else if (current == "building_bg.png") {
                    if (realEstate.handleClick(mousePos, moneyDisplay)) {
                        updateTotalAsset();
                    }
                    else if (sf::FloatRect(352, 92, 27, 23).contains(mousePos)) {
                        background.load(lastScene, window);
                        shouldShowCharacter = isCharacterBackground(lastScene);
                    }
                }
                // 친구 화면
                else if (current == "friends_bg.png") {
                    if (friendSystem.handleClick(mousePos, moneyDisplay)) {
                        updateTotalAsset();
                    }
                    else if (sf::FloatRect(354, 92, 27, 23).contains(mousePos)) {
                        background.load(lastScene, window);
                        shouldShowCharacter = isCharacterBackground(lastScene);
                    }
                }
                // 구걸장소 이동 화면
                else if (current == "MovingBeggingPlace_bg.png") {
                    if (sf::FloatRect(23, 159, 157, 189).contains(mousePos)) {
                        background.load("bg_playground.png", window);
                        shouldShowCharacter = true;
                    }
                    else if (sf::FloatRect(209, 159, 155, 192).contains(mousePos)) {
                        background.load("bg_dujeongStaion.png", window);
                        shouldShowCharacter = true;
                    }
                    else if (sf::FloatRect(24, 438, 157, 187).contains(mousePos)) {
                        background.load("bg_seouStation.png", window);
                        shouldShowCharacter = true;
                    }
                    else if (sf::FloatRect(208, 436, 156, 185).contains(mousePos)) {
                        background.load("bg_google.png", window);
                        shouldShowCharacter = true;
                    }
                    else if (sf::FloatRect(352, 92, 27, 23).contains(mousePos)) {
                        background.load(lastScene, window);
                        shouldShowCharacter = isCharacterBackground(lastScene);
                    }
                }
                // 메인 게임 화면들
                else if (current != "MovingBeggingPlace_bg.png" && current != "friends_bg.png" && current != "Achieve_bg.png") {
                    if (clickableArea.getGlobalBounds().contains(mousePos)) {
                        lastScene = current;
                        background.load("MovingBeggingPlace_bg.png", window);
                        shouldShowCharacter = false;
                    }
                    else if (sf::FloatRect(13, 570, 181, 39).contains(mousePos)) {
                        lastScene = current;
                        background.load("friends_bg.png", window);
                        shouldShowCharacter = false;
                    }
                    else if (sf::FloatRect(200, 570, 181, 39).contains(mousePos)) {
                        lastScene = current;
                        background.load("KUN power_bg.png", window);
                        shouldShowCharacter = false;
                    }
                    else if (sf::FloatRect(15, 621, 181, 39).contains(mousePos)) {
                        lastScene = current;
                        background.load("building_bg.png", window);
                        shouldShowCharacter = false;
                    }
                    else if (friendSystem.handleClick(mousePos, moneyDisplay)) {
                        updateTotalAsset();
                    }
                }
            }
        }
    }

    void update() {
        std::string current = background.getCurrentFile();

        if (shouldShowCharacter && isCharacterBackground(current)) {
            character.update();
        }

        friendSystem.updateIncome(moneyDisplay);
        achievementSystem.updateEffects(); // 에너지 드링크 효과 업데이트

        updateTotalAsset();

        // 업적 업데이트
        int goldPerClick = knuPowerSystem.getGoldPerClick(
            friendSystem.isFriendOwned(0),
            friendSystem.isFriendOwned(1),
            friendSystem.isFriendOwned(2),
            realEstate.getOwnedPropertyCount()
        );
        int friendIncome = friendSystem.getTotalFriendIncome();
        int knuLevel = knuPowerSystem.getLevel();
        int friendCount = friendSystem.getOwnedFriendCount();

        achievementSystem.updateAchievements(goldPerClick, friendIncome, knuLevel, friendCount);
    }

    void render() {
        window.clear();
        std::string current = background.getCurrentFile();

        if (current == "building_bg.png") {
            realEstate.draw(window);
        }
        else if (current == "KUN power_bg.png") {
            knuPowerSystem.draw(window);
        }
        else if (current == "friends_bg.png") {
            background.draw(window);
            friendSystem.draw(window);
        }
        else if (current == "Achieve_bg.png") {
            background.draw(window);
            achievementSystem.draw(window); // 업적 메달과 보상 버튼 그리기
        }
        else {
            background.draw(window);

            if (shouldShowCharacter && isCharacterBackground(current)) {
                character.draw(window);

                if (friendSystem.isFriendOwned(0)) window.draw(mjSprite);
                if (friendSystem.isFriendOwned(1)) window.draw(ahSprite);
                if (friendSystem.isFriendOwned(2)) window.draw(jsSprite);
            }
        }

        // 업적 화면이 아닐 때만 돈과 자산 표시
        if (current != "Achieve_bg.png") {
            moneyDisplay.draw(window);
            window.draw(assetText);
            // 에너지 드링크 개수 표시
            window.draw(blueDrinkText);
            window.draw(redDrinkText);
            // 효과 표시
            window.draw(effectText);
        }

        window.display();
    }
};

int main() {
    Game game;
    if (!game.init()) {
        std::cerr << "게임 초기화 실패!" << std::endl;
        return -1;
    }


    game.run();
    return 0;
}
